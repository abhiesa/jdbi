= Jdbi 3 Developer Guide
:doctype: book
:toc: left
:toclevels: 3
:sectanchors:
:sectlinks:
:sectnums:
:linkattrs:
:icons: font
:source-highlighter: coderay
:source-language: asciidoc
:exampledir: ../test/java/jdbi/doc
:jdbidocs: ./apidocs/org/jdbi/v3
:jdkdocs: https://docs.oracle.com/javase/8/docs/api

////
Style guidelines:
* 80 characters per line, except when you can't break it up e.g. links or
  asciidoc directives
* Best edited while drunk
////

== Introduction to Jdbi

The *Jdbi* library provides convenient, idiomatic access to relational data in
Java.

Jdbi is built on top of JDBC. If your database has a JDBC driver, you can use
Jdbi with it.

Jdbi's API comes in two flavors:

=== Fluent API

The Core API provides a fluent, imperative interface.

[source,java,indent=0]
----
include::{exampledir}/IntroductionTest.java[tags=core]
----

=== Declarative API

The SQL Object API sits atop Core, and provides a declarative interface.

[source,java,indent=0]
----
include::{exampledir}/IntroductionTest.java[tags=sqlobject-declaration]
----

[source,java,indent=0]
----
include::{exampledir}/IntroductionTest.java[tags=sqlobject-usage]
----

Jdbi has a flexible plugin architecture which makes it easy to fold in support
for your favorite libraries (Guava, JodaTime, Spring) or database vendor
(Oracle, Postgres).

Jdbi is not an ORM. There is no session cache, change tracking, "open session
in view", or cajoling the library to understand your schema.

Instead, Jdbi provides straightforward mapping between SQL and simple tabular
data structures.

You bring your own SQL, and Jdbi only runs the commands you tell it to--the way
God intended.

[NOTE]
Jdbi 3 is currently in beta. While we are reasonably confident in its
quality, we recommend thoroughly testing your code with Jdbi 3 before using it
in a production environment. http://www.jdbi.org[jdbi2] is still the stable
release.

== Setting Up Jdbi

Jdbi is easy to include in your Java project - with an
link:https://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0] license, few
external dependencies, and JARs distributed through
link:http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.jdbi%22%20AND%20v%3A%22{project_version}%22[Maven Central],
you can just include the relevant artifacts in your POM:

[source,xml,subs="attributes,specialchars"]
----
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.jdbi</groupId>
      <artifactId>jdbi3-parent</artifactId>
      <type>pom</type>
      <version>{project_version}</version>
      <scope>import</scope>
  </dependency>
</dependencyManagement>

<dependencies>
  <!-- The core library -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3</artifactId>
  </dependency>

  <!-- All other dependencies are optional -->

  <!-- SQL Object extension -- most people use this -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-sqlobject</artifactId>
  </dependency>

  <!-- Support Guava collection types and Optional -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-guava</artifactId>
  </dependency>

  <!-- Support JodaTime v2's DateTime -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-jodatime2</artifactId>
  </dependency>

  <!-- Minimal support for JPA annotations. -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-jpa</artifactId>
  </dependency>

  <!-- Automatically map kotlin data classes -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-kotlin</artifactId>
  </dependency>

  <!-- Support Kotlin default methods, default parameters in SQL Objects -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-kotlin-sqlobject</artifactId>
  </dependency>

  <!-- Support Oracle returning DML statements -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-oracle12</artifactId>
  </dependency>

  <!-- Adds support for most data types supported by Postgres driver -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-postgres</artifactId>
  </dependency>

  <!-- A factory bean to set up Jdbi singleton -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-spring4</artifactId>
  </dependency>

  <!-- Use StringTemplate4 template engine, instead of JDBI's -->
  <dependency>
    <groupId>org.jdbi</groupId>
    <artifactId>jdbi3-stringtemplate4</artifactId>
  </dependency>
</dependencies>
----

== Basic Usage

=== Jdbi

The link:{jdbidocs}/core/Jdbi.html[Jdbi] class is the main entry point into
the library.

Each `Jdbi` instance wraps a JDBC
link:{jdkdocs}/javax/sql/DataSource.html[DataSource].
It is also a repository of configuration for your database session.

There are a few ways to create a `Jdbi` instance. You can use a JDBC URL:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=createJdbi]
----

If you have a `DataSource` object, you can use that directly:

[source,java]
----
DataSource ds = ...
Jdbi jdbi = Jdbi.create(ds);
----

`Jdbi` instances are thread-safe and do not own any database resources.

Typically applications create a single, shared `Jdbi` instance, and set up
any common configuration there.

In a more limited scope (such as an HTTP request, or event callback),
you would then request a `Handle` object from your `Jdbi` instance.

=== Handle

Handles represent an active
link:{jdkdocs}/java/sql/Connection.html[database connection].

link:{jdbidocs}/core/Handle.html[Handle] is used to prepare and run SQL
statements against the database, and manage database transactions. It provides
access to fluent statement APIs that can bind parameters, execute the
statement, and then map any results into Java objects.

A `Handle` inherits configuration from the `Jdbi` at the time it is created.

[CAUTION]
Because `Handle` holds an open connection, care must be taken to ensure
that each handle is closed when you are done with it. Failure to close
Handles will eventually overwhelm your database with connections, or
drain your connection pool.

There are a few ways to get a `Handle`.

If your operation will return some result, use
link:{jdbidocs}/core/Jdbi.html#withHandle-org.jdbi.v3.core.HandleCallback-[jdbi.withHandle()]:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=withHandle]
----

If your operation does not need to return a result,
use `Jdbi.useHandle(HandleConsumer)`:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=useHandle]
----

Both `withHandle` and `useHandle` open a temporary handle, call your callback,
and immediately release the handle when your callback returns.

[TIP]
You may notice the "consumer" vs "callback" naming pattern in a few
places in Jdbi. Callbacks return a value, and are coupled to `with-` methods.
Consumers do not return a value, and are coupled to `use-` methods.

Alternatively, if you want to manage the lifecycle of the handle yourself,
use `jdbi.open()`:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=openHandle]
----

[CAUTION]
When using `jdbi.open()`, you should always use try-with-resources or a
try-finally block to ensure the database connection is released. Failing to
release the handle will leak connections. We recommend using `withHandle`
or `useHandle` over `open` whenever possible.

=== Parameters

You have two choices when binding parameters to a SQL statement: positional,
or named.

Any statement can use either position or named parameters, but they can never
be mixed in the same SQL statement. In this case, Jdbi can't be sure it's
binding the right parameters, and will throw an exception.

==== Positional Parameters

When you use a `?` token in a SQL statement, Jdbi replaces it with the value
you bind to the corresponding index (0-based):

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=positionalParameters]
----

==== Named Parameters

When you use a colon-prefixed token like `:name` in a SQL statement, Jdbi
replaces it with the value you bind to that name:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=namedParameters]
----

==== Supported Types

Out of the box, Jdbi supports the following types as SQL statement parameters:

* Primitives: `boolean`, `byte`, `short`, `int`, `long`, `char`, `float`, and
  `double`
* java.lang: `Boolean`, `Byte`, `Short`, `Integer`, `Long`, `Character`,
  `Float`, `Double`, `String`, and `Enum` (stored as the enum value's name)
* java.math: `BigDecimal`
* java.net: `Inet4Address`, `Inet6Address`, `URL`, and `URI`
* java.sql: `Blob`, `Clob`, `Date`, `Time`, and `Timestamp`
* java.time: `Instant`, `LocalDate`, `LocalDateTime`, `LocalTime`,
  `OffsetDateTime`, and `ZonedDateTime`
* java.util: `Date`, `Optional` (around any other supported type), and `UUID`
* `java.util.Collection` and Java arrays (stored as SQL arrays). Some
  additional setup may be required depending on the type of array element.

You can also configure Jdbi to support additional parameter types. More on that
later.

==== Binding Parameters

SQL statement parameters can be bound in a few different ways.

You can bind parameters individually:

[source,java]
----
handle.createUpdate("insert into contacts (id, name) values (:id, :name)")
      .bind("id", 1)
      .bind("name", "Alice")
      .execute();
----

You can bind from the entries of a `Map`:

[source,java]
----
Map<String, Object> params = new HashMap<>();
params.put("id", 2)
params.put("name", "Bob");

handle.createUpdate("insert into contacts (id, name) values (:id, :name)")
      .bindMap(contact)
      .execute();
----

You can bind from properties of a Java Bean:

[source,java]
----
Contact contact = Contact();
contact.setId(3);
contact.withName("Cindy");

handle.createUpdate("insert into contacts (id, name) values (:id, :name)")
      .bindBean(contact)
      .execute();
----

Optionally, you can qualify each bound bean with a prefix. This can help remove
ambiguity in situations where two or more bound beans have similar property
names:

[source,java]
----
Folder folder = new Folder(1, "Important Documents");
Document document = new Document(100, "memo.txt", "Business business business. Numbers.");

handle.createUpdate("insert into documents (id, folder_id, name, contents) " +
                    "values (:d.id, :f.id, :d.name, :d.contents)")
      .bindBean("f", folder)
      .bindBean("d", document)
      .execute();
----

[WARNING]
Neither `bindMap()` nor `bindBean()` support binding of nested properties (e.g.
`:user.address.street`).

=== SQL Objects

SQL Objects are a declarative-style alternative to the fluent-style Core API.

With SQL Object, you declare a public interface, add methods for each database
operation, and specify what SQL statement to execute.

You can specify what each method does in one of two ways:

* Annotate the method with a SQL method annotation. Jdbi provides four of these
  annotations out of the box (updates, queries, stored procedure calls, and
  batches).
* Declare the method as a Java 8 `default` method, and provide your own
  implementation in the method body.

At runtime, you can request an instance of your interface, and Jdbi synthesizes
an implementation based on the annotations and methods you declared.

==== Annotated Methods

Methods annotated with one of Jdbi's SQL method annotations
(link:{jdbidocs}/sqlobject/statement/SqlBatch.html[@SqlBatch],
link:{jdbidocs}/sqlobject/statement/SqlCall.html[@SqlCall],
link:{jdbidocs}/sqlobject/statement/SqlQuery.html[@SqlQuery], or
link:{jdbidocs}/sqlobject/statement/SqlUpdate.html[@SqlUpdate]) have their
implementation generated automatically, based on the annotations on the method,
and its parameters.

The parameters to the method are used as inputs to the statement, and the
SQL statement result mapped into the the return type.

===== Binding Parameters

Arguments passed to the method are bound as parameters to the SQL statement.

If using positional parameters, the method arguments are bound to the
corresponding `?` parameter marker in the SQL statement:

[source,java]
----
public interface UserDao {
  @SqlUpdate("insert into users (id, name) values (?, ?)")
  void insert(long id, String name);
}
----

You can use named parameters with the `@Bind` annotation:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:id, :name)")
void insert(@Bind("id") long id, @Bind("name") String name);
----

You can bind from the entries of a `Map`:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:id, :name)")
void insert(@BindMap Map<String, ?> map);
----

In SQL Object (but not in Core), you can qualify a bound map with a prefix:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:user.id, :user.name)")
void insert(@BindMap("user") Map<String, ?> map);
----

You can bind from the properties of a Java Bean:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:id, :name)")
void insert(@BindBean User user);
----

Like `@BindMap`, you can qualify a bound bean with a prefix:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:user.id, :user.name)")
void insert(@BindBean("user") User user);
----

[WARNING]
As in the Core API, neither `@BindMap` nor `@BindBean` support binding of
nested properties (e.g. `:user.address.street`).

===== Automatic parameter naming

Normally, you must explicitly declare a `@Bind` annotation and specify the name
to which the argument will be bound:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:id, :name)")
void insert(@Bind("id") long id, @Bind("name") String name);
----

If you compile your SQL Object interfaces with the `-parameters` flag enabled,
then Jdbi can then automatically name your bound parameters based on the method
parameter name. Thus:

[source,java]
----
@SqlUpdate("insert into users (id, name) values (:id, :name)")
void insert(long id, String name);
----

====== Maven setup

Configure the `maven-compiler-plugin` in your POM:

[source,xml]
----
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <compilerArgs>
      <arg>-parameters</arg>
    </compilerArgs>
  </configuration>
</plugin>
----

====== IntelliJ IDEA setup

* File -> Settings
* Build, Execution, Deployment -> Compiler -> Java Compiler
* Additional command-line parameters: `-parameters`
* Click Apply, then OK.
* Build -> Rebuild Project

====== Eclipse setup

* Window -> Preferences
* Java -> Compiler
* Under "Classfile Generation," check the option "Store information about
  method parameters (usable via reflection)."

==== Default Methods

Occasionally a use case comes up where SQL Method annotations don't fit. In
these situations, you can "drop down" to the Core API using a Java 8 `default`
method.

Jdbi provides a `SqlObject` mixin interface with a single method:

[source,java]
----
public interface SqlObject {
  Handle getHandle();
}
----

Make your SQL Object interface extend the `SqlObject` mixin, then provide your
own implementation in a default method:

[source,java]
----
public interface SplineDao extends SqlObject {
  default void reticulateSplines(Spline spline) {
    Handle handle = getHandle();
    // do tricky stuff using the Core API.
  }
}
----

Default methods can also be used to group multiple SQL operations into a single
method call:

[source,java]
----
public interface ContactPhoneDao {
  @SqlUpdate("insert into contacts (id, name) values (nextval('contact_id'), :name)")
  long insertContact(@BindBean Contact contact);

  @SqlBatch("insert into phones (contact_id, type, phone) values (:contactId, :type, :phone)")
  void insertPhone(long contactId, @BindBean Iterable<Phone> phones);

  default long insertFullContact(Contact contact) {
    long id = insertContact(contact);
    insertPhone(id, contact.getPhones());
    return id;
  }
}
----

==== Using SQL Objects

Once you've defined your interface, there are a few ways to get an instance of
it:

===== Attached to Handle

You can get a SQL Object that is attached to an open handle.

[source,java]
----
try (Handle handle = jdbi.open()) {
  ContactPhoneDao dao = handle.attach(ContactPhoneDao.class);
  dao.insertFullContact(contact);
}
----

Attached SQL Objects have the same lifecycle as the handle--when the handle is
closed, the SQL Object becomes unusable.

===== Temporary SQL Objects

You can also get a temporary SQL Object from the Jdbi object, by passing it a
callback (typically a lambda). Use
link:{jdbidocs}/core/Jdbi.html#withExtension-java.lang.Class-org.jdbi.v3.core.extension.ExtensionCallback-[Jdbi.withExtension]
for operations that return a result, or
link:{jdbidocs}/core/Jdbi.html#useExtension-java.lang.Class-org.jdbi.v3.core.extension.ExtensionConsumer-[useExtension]
for operations with no result.

[source,java]
----
jdbi.useExtension(ContactPhoneDao.class, dao -> dao.insertFullContact(alice));
long bobId = jdbi.withExtension(ContactPhoneDao.class, dao -> dao.insertFullContact(bob));
----

Temporary SQL Objects are only valid inside the callback you pass to the
method. The SQL Object (and the associated temporary handle) are closed when
the callback returns.

===== On-Demand

On-demand instances have an open-ended lifecycle, as they obtain and releases
connections for each method call. They are thread-safe, and may be reused
across an application. This is handy when you only need to make single calls at
a time.

[source,java]
----
ContactPhoneDao dao = jdbi.onDemand(ContactPhoneDao.class);
long aliceId = dao.insertFullContact(alice);
long bobId = dao.insertFullContact(bob);
----

[WARNING]
There is a performance penalty every time a connection is allocated and
released. If you need to make successive calls to a SQL Object, consider using
one of the above options for better performance, instead of on-demand.

//=== Statements
//
//*jdbi* provides fluent builders for various types of queries, updates, and
//batch statements.

=== Queries

==== Core
A link:{jdbidocs}/core/statement/Query.html[Query] is a
link:{jdbidocs}/core/result/ResultBearing.html[result-bearing] SQL statement
that returns a result set from the database.

//[source,java,indent=0]
//----
//include::{exampledir}/StatementsTest.java[tags=query]
//----

For single rows, you can use `findOnly()`, which expects exactly one row (or
throws an exception)::

[source,java]
----
String name = handle.select("select name from users where id = ?", 3)
    .mapTo(String.class)
    .findOnly();
----

You can also use `findFirst()`, which returns an `Optional` of the mapped type:

[source,java]
----
Optional<String> name = handle.createUpdate("select name from users where id = :id")
    .bind("id", 3)
    .mapTo(String.class)
    .findFirst();
----

Multiple result rows can be returned in a list:

[source,java]
----
List<String> name = handle.createQuery("select title from films where genre = :genre order by title")
    .bind("genre", "Action")
    .mapTo(String.class)
    .list();
----

For other collections, use `collect()` with a
link:{jdkdocs}/java/util/stream/Collector.html[collector]:

[source,java]
----
Set<String> name = handle.createQuery("select title from films where genre = :genre order by title")
    .bind("genre", "Action")
    .mapTo(String.class)
    .collect(Collectors.toSet());
----

You can also stream results:

[source,java]
----
handle.createQuery("select title from films where genre = :genre order by title")
    .mapTo(String.class)
    .useStream(stream -> {
      // do stuff with stream
    });
----

Thus far, all examples have shown a `String` result type. Of course, you can
map to many other data types:

[source,java]
----
LocalDate releaseDate = handle.createQuery("select release_date from films where name = :name")
    .bind("name", "Star Wars: A New Hope")
    .mapTo(LocalDate.class)
    .findOnly();
----

Out of the box, Jdbi supports mapping database columns to the following types:

* Primitives: `boolean`, `byte`, `short`, `int`, `long`, `char`, `float`, and
  `double`
* java.lang: `Boolean`, `Byte`, `Short`, `Integer`, `Long`, `Character`,
  `Float`, `Double`, `String`, and `Enum` (stored as the enum value's name)
* java.math: `BigDecimal`
* `byte[]` arrays (e.g. for BLOB or VARBINARY columns)
* java.net: `InetAddress`, `URL`, and `URI`
* java.sql: `Timestamp`
* java.time: `Instant`, `LocalDate`, `LocalDateTime`, `LocalTime`,
  `OffsetDateTime`, and `ZonedDateTime`
* java.util: `UUID`
* `java.util.Collection` and Java arrays (for array columns). Some
  additional setup may be required depending on the type of array element.

Jdbi can also be configured to support additional data types.

Declaring a class that closely maps to your database table makes mapping to or
from database rows simple:

==== SQL Object

=== Updates

Updates are operations that return an integer number of rows modified, such
as a database *INSERT*, *UPDATE*, or *DELETE*.

[source,java,indent=0]
----
include::{exampledir}/StatementsTest.java[tags=update]
----

=== Scripts

A *Script* parses a String into semicolon terminated statements. The statements
can be executed in a single *Batch* or individually.

[source,java,indent=0]
----
include::{exampledir}/StatementsTest.java[tags=script]
----

=== Stored Procedure Calls

A *Call* invokes a database stored procedure.

[source,java,indent=0]
----
include::{exampledir}/CallTest.java[tags=call]
----

// This section needs some help, in particular, how the hell does the out
// parameter mapping above work?

=== Batches

A *Batch* or *PreparedBatch* sends many rows to the server in bulk. After
opening the batch, repeatedly add bound parameters or statements, and invoke
*add*.

The result is a list of modified row count.

[source,java,indent=0]
----
include::{exampledir}/StatementsTest.java[tags=batch]
----

=== Arguments

Most non-trivial queries require binding arguments from Java land to the
statement.  In addition to binding by index (which is zero-based in *jdbi*,
unlike JDBC's bizarre one-indexing scheme), named parameters are supported out
of the box.

All primitive and many core Java types come with predefined bindings.

[source,java,indent=0]
----
include::{exampledir}/ArgumentsTest.java[tags=bindValue]
----

You also have a couple of options to deal with custom types. The *Argument*
class wraps a single value into a binding.

[source,java,indent=0]
----
include::{exampledir}/ArgumentsTest.java[tags=uuidArgument]
----

<1> Since Argument usually directly calls into JDBC directly, it is given the
*one-based index* when it is applied.

Here we use an *Argument* to directly bind a UUID. In this particular case,
the most obvious approach is to send the UUID to the database as a String. If
your JDBC driver supports custom types directly or efficient binary transfers,
you can leverage them easily here.

[source,java,indent=0]
----
include::{exampledir}/ArgumentsTest.java[tags=uuidArgumentFactory]
----

You can also register *ArgumentFactory* instances which can inspect the type of
bindings and determine if they understand how to convert the type to Arguments.

=== Results

After executing a database query, you need to interpret the results. JDBC
provides the *ResultSet* class which can do simple mapping to Java primitives
and built in classes, but the API is often cumbersome to use. *jdbi* provides
configurable mapping, including the ability to register custom mappers for rows
and columns.

A *RowMapper* converts a row of a *ResultSet* into a result object.

A *ColumnMapper* converts a single column's value into a Java object. It can be
used as a *RowMapper* if there is only one column present, or it can be used to
build more complex *RowMapper*s.

The mapper is selected based on the declared result type of your query.

*jdbi* iterates over the rows in the ResultSet and presents the mapped results
to you in a container such as a *List*, *Stream*, *Optional*, or *Iterator*.

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=headlineExample]
----

=== Row Mapper

The row mapper is called once for every row as *jdbi* iterates through the
result set.

Row mappers are either configured on a fluent query, or can be registered to
handle a type:

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=rowMapper]
----

This *RowMapper* is equivalent to the lambda mapper above but more explicit. We
also introduce the *Query.list()* method which collects all rows into a
*List<T>* object.

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=rowMapperFactory]
----

The Factory is allowed to consider whether it can handle any given *Type* and
provides the above RowMapper to do the actual work.

*Stream* integration allows you to use a RowMapper to adapt a ResultSet into
the new Java 8 Streams framework. As long as your database supports streaming
results (for example, PostgreSQL will do it as long as you are in a transaction
and set a fetch size), the stream will lazily fetch rows from the database as
necessary.

==== Constructor Mapper

*jdbi* provides a simple constructor mapper which uses reflection to assign
columns to constructor parameters by name. Unfortunately parameter names are
not enabled by default and require a compiler option, but once you have that
enabled the result is quite concise:

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=constructorMapper]
----

The parameter names "id", "name" match the database column names and as such no
custom mapper code is required at all.

=== Column Mapper

Sometimes you only wish to fetch a single value, or need to build a larger
object out of multiple individually mappable elements. A column mapper works on
a single column instead of by row:

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=columnMapper]
----

Notice how the ConstructorMapper, which usually would not know
what to do with a custom *UserName* object, now automatically
uses the column mapper to fill in the constructor parameter.

=== Bean Mapper

We also provide basic support for beans:

[source,java,indent=0]
----
include::{exampledir}/ResultsTest.java[tags=beanMapper]
----

=== Annotations

You can register mappers declaratively on SqlObjects using e.g.
`@RegisterRowMapper`, `@RegisterColumnMapper`, `@RegisterConstructorMapper`,
and so on.

=== ResultBearing

The *ResultBearing* interface determines how the statement results are gathered
and returned to you. The methods are designed to interact well with the new
Java 8 *@FunctionalInterface*s and *Stream* library. Given a type T that can be
mapped by the registered mappers,

==== Find a Single Result

*ResultBearing#findOnly* returns the only row in the result set. If zero or
multiple rows are encountered, it will throw *IllegalStateException*.

*#findFirst* returns an *Optional<T>* with the first row, if any.

==== Stream

*#stream* returns a *Stream<T>*. You should then process the stream and produce
a result. This stream must be closed to release any database resources held, so
we recommend using a *try-with-resources* block to ensure that no resources are
leaked.

*#withStream* and *#useStream* handle closing the stream for you. You provide a
*StreamCallback* that produces a result or a *StreamConsumer* that produces no
result, respectively.

==== Collections

*#list* emits a *List<T>*. This necessarily buffers all results in memory.

*#collect* takes a *Collector<T, ? , R>* that builds a resulting collection
*R<T>*. The *java.util.stream.Collectors* class has a number of interesting
*Collector*s to start with.

==== Reduction

*#reduce* provides a simplified *Stream#reduce*. Given an identity starting
value and a *BiFunction<U, T, U>* it will repeatedly combine *U*s until only a
single remains, and then return that.

=== Joins

:coreexampledir: {exampledir}/../../../../../../core/src/test/java/org/jdbi/v3/core/mapper
:sqlobjectexampledir: {exampledir}/../../../../../../sqlobject/src/test/java/org/jdbi/v3/sqlobject

Joining multiple tables together is a very common database task. It is also
where the mismatch between the relational model and Java's object model starts
to rear its ugly head.

Here we present a couple of strategies for retrieving results from more
complicated rows.

==== JoinRowMapper

The JoinRowMapper takes a set of types to extract from each row. It uses the
mapping registry to determine how to map each given type, and presents you with
a JoinRow that holds all of the resulting values.

Let's consider two simple types, User and Article, with a join table named
Author. Guava provides a Multimap class which is very handy for representing
joined tables like this. Assuming we have mappers already registered:

[source,java,indent=0]
----
include::{coreexampledir}/JoinRowMapperTest.java[tags=mapperSetup]
----

we can then easily populate a Multimap with the mapping from the database:

[source,java,indent=0]
----
include::{coreexampledir}/JoinRowMapperTest.java[tags=multimap]
----

NOTE: While this approach is easy to read and write, it can be inefficient for
certain patterns of data. Consider performance requirements when deciding
whether to use high level mapping or more direct low level access with
handwritten mappers.

You can also use it with SqlObject:

[source,java,indent=0]
----
include::{sqlobjectexampledir}/TestRegisterJoinRowMapper.java[tags=joinrow]
----

=== Generated Keys

Inserts and related queries may automatically generate keys. These keys are
treated separately from normal results. Depending on your database and
configuration, the entire inserted row may be available.

WARNING: Unfortunately there is a lot of variation between databases supporting
this feature so please test this feature's interaction with your database
thoroughly.

In PostgreSQL, the entire row is available, so you can immediately map your
inserted names back to full User objects!  This avoids the overhead of
separately querying after the insert completes.

Consider the following table:

[source,java,indent=0]
----
include::{exampledir}/GeneratedKeysTest.java[tags=setup]
----

You can get generated keys in the fluent style:

[source,java,indent=0]
----
include::{exampledir}/GeneratedKeysTest.java[tags=fluent]
----

SqlObject style works just as well:

[source,java,indent=0]
----
include::{exampledir}/GeneratedKeysTest.java[tags=sqlObject]
----

== Transactions

*jdbi* provides full support for JDBC transactions.

=== Transactions in the Fluent API

*Handle* objects provide two ways to open a transaction -- *inTransaction*
allows you to return a result, and *useTransaction* has no return value.

Both optionally allow you to specify the transaction isolation level.

[source,java,indent=0]
----
include::{exampledir}/TransactionTest.java[tags=simpleTransaction]
----

Here, we (probably unnecessarily) guard a simple _SELECT_ statement with a
transaction.

=== Transactions in SqlObject API

Similarly, you may declare transactions with SqlObject annotations:

[source,java,indent=0]
----
include::{exampledir}/TransactionTest.java[tags=sqlObjectTransaction]
----

SQL methods with a `@Transaction` annotation may optionally specify a
transaction isolation level:

[source,java,indent=0]
----
include::{exampledir}/TransactionTest.java[tags=sqlObjectTransactionIsolation]
----

If a `@Transaction` method calls another `@Transaction` method, they must
specify the same isolation level, or the inner method must not specify
anything, in which case the isolation level of the outer method is used.

[source,java,indent=0]
----
include::{exampledir}/TransactionTest.java[tags=sqlObjectNestedTransaction]
----

=== Serializable Transactions

For more advanced queries, sometimes serializable transactions are required.
*jdbi* includes a transaction runner that is able to retry transactions that
abort due to serialization failures. It is important that your transaction does
not have side effects as it may be executed multiple times.

[source,java,indent=0]
----
include::{exampledir}/TransactionTest.java[tags=serializable]
----

The above test is designed to run two transactions in lock step. Each attempts
to read the sum of all rows in the table, and then insert a new row with that
sum. We seed the table with the values 10 and 20.

Without serializable isolation, each transaction reads 10 and 20, and then
returns 30. The end result is 30 + 30 = 60, which does not correspond to any
serial execution of the transactions!

With serializable isolation, one of the two transactions is forced to abort and
retry. On the second go around, it calculates 10 + 20 + 30 = 60. Adding to 30
from the other, we get 30 + 60 = 90 and the assertion succeeds.

== Batch Updates

Normally, every statement executed requires a round-trip to the database
server. When inserting or updating a large number of records, this can add
unacceptable amounts of latency. JDBC provides support for batching independent
statements via
link:http://docs.oracle.com/javase/8/docs/api/java/sql/Statement.html#executeBatch--[Statement.executeBatch]
as well as a single statement with many varying bound arguments via
link:http://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#addBatch--[PreparedStatement.addBatch].

*jdbi* exposes this functionality through the *Batch* and *PreparedBatch*
classes. Their use is straightforward. To execute many separate statements as a
single batch:

[source,java,indent=0]
----
include::{exampledir}/BatchTest.java[tags=simpleBatch]
----

If you have a single statement but want to bind many groups of parameters:

[source,java,indent=0]
----
include::{exampledir}/BatchTest.java[tags=preparedBatch]
----

We also support SqlObject batch inserts:

[source,java,indent=0]
----
include::{exampledir}/BatchTest.java[tags=sqlObjectBatch]
----

== Exception Rewriting

The JDBC SQLException class is very old and predates more modern exception
facilities like Throwable's suppressed exceptions. When a batch fails, there
may be multiple failures to report, which could not be represented by the base
Exception types of the day.

So SQLException has a bespoke
link:http://docs.oracle.com/javase/8/docs/api/java/sql/SQLException.html#getNextException--[getNextException]
chain to represent the causes of a batch failure. Unfortunately, by default
most logging libraries do not print these exceptions out, pushing their
handling into your code. It is very common to forget to handle this situation
and end up with logs that say nothing other than

----
java.sql.BatchUpdateException: Batch entry 1 insert into something (id, name) values (0, '') was aborted. Call getNextException to see the cause.
----

*jdbi* will attempt to rewrite such nextExceptions into "suppressed exceptions"
(new in Java 8) so that your logs are more helpful:

----
java.sql.BatchUpdateException: Batch entry 1 insert into something (id, name) values (0, 'Keith') was aborted. Call getNextException to see the cause.
Suppressed: org.postgresql.util.PSQLException: ERROR: duplicate key value violates unique constraint "something_pkey"
  Detail: Key (id)=(0) already exists.
----

== SqlObject
=== @SingleValue

Sometimes when using advanced SQL features like Arrays, a container type like
`int[]` or `List<Integer>` can ambiguously mean either "a single SQL int[]" or
"a ResultSet of int". Since arrays are not commonly used in normalized schema,
jdbi assumes that you are collecting a ResultSet into a container object. You
can annotate a return type as `@SingleValue` to override this.

=== Sql Locators

TODO

== Third Party Integration

=== Spring

TODO

=== Google Guava

TODO

=== PostgreSQL

*jdbi3-postgres* provides enhanced integration with the
link:https://jdbc.postgresql.org/[PostgreSQL JDBC Driver].

[source,java,indent=0]
----
Jdbi jdbi = Jdbi.create("jdbc:postgresql://host:port/database")
                .installPlugin(new PostgresPlugin());
----

The plugin configures mappings for the Java 8 *java.time* types like
*Instant* or *Duration*, *UUID*, typed enums, and *hstore*.

See the
link:https://jdbi.github.io/apidocs/org/jdbi/v3/postgres/package-summary.html[javadoc]
for an exhaustive list.

=== Oracle

TODO

=== Kotlin

http://kotlinlang.org/[Kotlin] support is provided by *jdbi3-kotlin* and
*jdbi3-kotlin-sqlobject* modules.

==== ResultSet mapping

The *jdbi3-kotlin* plugin adds ResultSet mapping to Kotlin data classes. It
supports data classes where all fields are present in the constructor as well
as classes with writable properties. Any fields not present in the constructor
will be set after the constructor call. The mapper supports nullable types. It
also uses default parameter values in the constructor if the parameter type is
not nullable and the value absent in the result set.

Result set mapper also supports `@ColumnName` annotation that allows to specify
name for a property or parameter explicitly.

If you load all Jdbi plugins via `Jdbi.installPlugins()` this plugin will be
discovered and registered automatically. Otherwise, you can attach it using
`Jdbi.installPlugin(KotlinPlugin())`.

An example from the test class:

[source,kotlin,indent=0]
----
include::{exampledir}/KotlinPluginTest.kt[tags=dataClass;testQuery]
----


There are two extensions to help:

* `<reified T : Any>ResultBearing.mapTo()`
* `<T : Any>ResultIterable<T>.useSequence(block: (Sequence<T>) -> Unit)`

Allowing code like:

[source,kotlin]
----
val qry = handle.createQuery("select id, name from something where id = :id")
val things = qry.bind("id", brian.id).mapTo<Thing>.list()
----

and for using a Sequence that is auto closed:

[source,kotlin]
----
qryAll.mapTo<Thing>.useSequence {
    it.forEach(::println)
}
----



==== SqlObject

The *jdbi3-kotlin-sqlobject* plugin adds automatic parameter binding by name
for Kotlin methods in SqlObjects as well as support for Kotlin default methods.

Parameter binding supports individual primitive types as well as Kotlin or
JavaBean style objects as a parameter (referenced in binding as
`:paramName.propertyName`). No annotations are needed.

If you load all Jdbi plugins via `Jdbi.installPlugins()` this plugin will be
discovered and registered automatically. Otherwise, you can attach the plugin
via: `Jdbi.installPlugin(KotlinSqlObjectPlugin())`.

An example from the test class:

[source,kotlin,indent=0]
----
include::{exampledir}/KotlinPluginTest.kt[tags=sqlObject;setUp;testDao]
----

== Appendix

=== API Reference

link:apidocs/index.html[Javadoc]

=== Contributing

*jdbi* uses GitHub for collaboration. Please check out the
link:https://github.com/jdbi/jdbi[project page] for more information.

If you have a question, we have a
link:https://groups.google.com/group/jdbi[Google Group mailing list]

Users sometimes hang out on
link:irc://irc.freenode.net/#jdbi[IRC in #jdbi on Freenode].

////

== Leftover snippets

Method annotations:

* `@SqlUpdate` - execute a statement, and return the update count (i.e. the
  number of rows modified).
* `@SqlBatch` - execute a statement multiple times, using a series of input
  parameters. Any array, vararg, or iterable parameters are interpreted as
  sequential inputs to the batch.
* `@SqlQuery` - execute a statement, and map the result set to the method
  return type. Query methods may return single value types (which returns the
  first row of the result), or a collection of rows.
* `@GetGeneratedKeys` - Return the keys generated by the SQL statement, instead
  of the update count. In the above example, this means returning the next
  value from the `contact_seq` sequence. This annotation modifies the return
  type of `@SqlUpdate` or `@SqlBatch` method.
* `@RegisterBeanMapper` - Tells Jdbi that result sets can be mapped to the
  given class (`Contact.class` in this case) by treating column names as bean
  properties. Any columns in `snake_case` are matched automatically to the
  equivalent `camelCase` property names.

[source,java,indent=0]
----
include::{exampledir}/SqlObjectTest.java[tags=defn]
----

Given a type *Something* that has *int id* and *String name* properties, we
define an interface, *SomethingDao*, that provides simple create and read
operations for a table.

Annotations at the class and method level control the binding of arguments and
mapping to results. For example, `@RegisterRowMapper` mirrors
`Handle.registerRowMapper`.

You produce results as single instances or container types like `Optional` or
`List`, same as `Query.mapTo`.

[source,java,indent=0]
----
include::{exampledir}/SqlObjectTest.java[tags=find-by-id]
----

There are also `@SqlBatch` and `@SqlCall` annotations. Check out the Javadoc
for more information.

=== Row Mappers

By default, queries map each row in the result set into a `Map<String, Object>`
which maps the column name to the column value. You can override this to map to
arbitrary row types using `Query.map(RowMapper<T>)`:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=defineCustomMapper]

include::{exampledir}/FiveMinuteTourTest.java[tags=useCustomMapper]
----

Registering a `RowMapper` with the `Handle` or the `Jdbi` (before the handle is
created) allows you to map to the data type without having to specify the
mapper type everywhere:

[source,java,indent=0]
----
include::{exampledir}/FiveMinuteTourTest.java[tags=registerCustomMapper]
----

////